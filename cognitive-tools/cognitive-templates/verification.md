# 验证模板

> "信任,但要验证。" — 俄罗斯谚语

## 概述

验证模板帮助语言模型检查自己的工作、捕获错误并确保输出质量。这些模板对于提高可靠性、减少幻觉和改善整体准确性至关重要。

```
┌──────────────────────────────────────────────────────────────┐
│                                                              │
│  验证过程                                                     │
│                                                              │
│  解决方案 → 检查逻辑 → 测试假设 → 纠正 → 最终结果             │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

## 基础模板

### 1. 解决方案验证

检查解决方案或答案的基本模板。

```markdown
# 解决方案验证模板

任务:验证以下解决方案的正确性。

问题:{{problem}}
提议的解决方案:{{solution}}

请遵循此验证过程:
1. **重述问题**:确认对所问内容的理解。
2. **检查方法**:使用的方法是否适合此问题?
3. **验证计算**:检查所有数学运算的准确性。
4. **检查逻辑**:检查推理中是否存在逻辑错误或漏洞。
5. **用例测试**:用具体示例或边缘情况测试解决方案。
6. **检查约束**:确保满足原始问题的所有约束。
7. **最终评估**:说明解决方案是否:
   - 正确:解决方案完全准确
   - 部分正确:解决方案存在小错误(请具体说明)
   - 不正确:解决方案存在重大缺陷(请具体说明)

如果发现错误,请清楚地解释并提出纠正建议。
```

**Token 数量**:~160 tokens(仅模板)

**使用示例**:
- 用于数学解决方案
- 检查逻辑论证时
- 用于任何需要准确性的输出

### 2. 事实核查

用于验证事实性声明和陈述。

```markdown
# 事实核查模板

任务:验证以下陈述的准确性。

陈述:{{statements}}

请遵循此验证过程:
1. **分解声明**:识别每个不同的事实性声明。
2. **评估知识库**:确定您是否拥有关于每个声明的可靠信息。
3. **验证每个声明**:
   - 声明 1:[重述声明]
     - 评估:[准确 / 不准确 / 部分准确 / 不确定]
     - 解释:[提供相关事实和上下文]
     - 置信度:[高 / 中 / 低]
   - 声明 2:[继续每个声明]
4. **检查遗漏**:识别任何缺失的相关上下文。
5. **整体评估**:总结整体准确性。
6. **知识局限**:注意任何无法自信验证的声明。

为任何不准确的信息提供更正。
```

**Token 数量**:~150 tokens(仅模板)

**使用示例**:
- 用于检查历史或科学声明
- 验证摘要中的信息时
- 用于任何包含事实断言的输出

### 3. 一致性检查

用于确保内容的内部一致性。

```markdown
# 一致性检查模板

任务:检查以下内容的内部一致性。

内容:{{content}}

请遵循此验证过程:
1. **识别关键要素**:注意主要声明、定义和论证。
2. **创建一致性映射**:
   - 要素 1:[描述]
   - 要素 2:[描述]
   - [继续所有重要要素]
3. **检查矛盾**:
   - 要素之间:比较每个要素与其他要素的兼容性
   - 要素内部:检查每个要素内部是否存在矛盾
4. **时间一致性**:确保事件和发展遵循逻辑时间线。
5. **术语一致性**:验证术语在整个内容中的使用一致性。
6. **逻辑流**:检查结论是否源于前提。
7. **最终评估**:总结发现的任何不一致之处。

对于每个不一致之处,解释矛盾并提出解决方案。
```

**Token 数量**:~160 tokens(仅模板)

**使用示例**:
- 用于长篇内容
- 检查复杂论证时
- 用于任何基于多个前提的输出

## 高级模板

### 4. 综合错误分析

用于跨多个维度详细检查潜在错误。

```markdown
# 综合错误分析模板

任务:对以下内容执行彻底的错误分析。

内容:{{content}}
上下文:{{context}}

请检查这些错误类型:
1. **事实错误**:
   - 不正确的陈述:[识别并纠正]
   - 过时的信息:[识别并更新]
   - 错误归因的陈述:[识别并纠正]

2. **逻辑错误**:
   - 错误等价:[识别]
   - 不连贯:[识别]
   - 循环推理:[识别]
   - 草率概括:[识别]

3. **数学/计算错误**:
   - 计算错误:[识别并纠正]
   - 公式应用错误:[识别并纠正]
   - 单位转换问题:[识别并纠正]

4. **上下文错误**:
   - 误解上下文:[澄清]
   - 不恰当的假设:[识别]
   - 缺少相关信息:[提供]

5. **语言错误**:
   - 模糊陈述:[澄清]
   - 不正确的术语:[纠正]
   - 不一致的语言:[标准化]

6. **结构错误**:
   - 组织问题:[识别]
   - 缺失的组件:[识别]
   - 冗余:[识别]

对于发现的每个错误,解释:
- 错误是什么
- 为什么它有问题
- 如何纠正它

总结内容的整体准确性和可靠性。
```

**Token 数量**:~240 tokens(仅模板)

**使用示例**:
- 用于重要内容的批判性审查
- 需要最大准确性时
- 用于同行评审或编辑流程

### 5. 替代视角分析

用于检查偏见和探索替代观点。

```markdown
# 替代视角分析模板

任务:从替代视角分析以下内容,以检查偏见或盲点。

内容:{{content}}

请遵循此过程:
1. **识别内容的视角**:什么世界观、假设或价值观构成内容的基础?

2. **探索替代视角**:
   - 视角 A:[描述不同的观点]
     - 此视角如何看待内容?
     - 它会批评或质疑什么?
     - 它会提出什么额外的考虑?

   - 视角 B:[描述另一个不同的观点]
     - 此视角如何看待内容?
     - 它会批评或质疑什么?
     - 它会提出什么额外的考虑?

   - [继续其他相关视角]

3. **识别盲点**:原始内容缺少哪些重要考虑?

4. **检查未陈述的假设**:内容认为理所当然但可能被质疑的是什么?

5. **平衡评估**:内容是否公平和平衡,还是偏向某些视角?

6. **建议**:建议修改以使内容更全面和平衡。

此分析有助于确保内容考虑了多样化的观点并避免无意的偏见。
```

**Token 数量**:~220 tokens(仅模板)

**使用示例**:
- 用于政策分析
- 检查文化或意识形态偏见时
- 用于任何涉及有争议主题的内容

### 6. 实施验证

用于检查解决方案是否可以实际实施。

```markdown
# 实施验证模板

任务:验证以下解决方案是否可以实际实施。

提议的解决方案:{{solution}}
实施上下文:{{context}}

请遵循此验证过程:
1. **可行性评估**:
   - 技术可行性:这是否可以用现有技术构建?
   - 资源需求:需要哪些资源(时间、资金、技能)?
   - 可扩展性:解决方案是否能在所需规模下工作?

2. **约束检查**:
   - 技术约束:解决方案是否尊重技术限制?
   - 监管约束:它是否符合相关法规?
   - 运营约束:它是否可以在运营参数内实施?

3. **风险分析**:
   - 实施风险:实施过程中可能出什么问题?
   - 运营风险:实施后可能出什么问题?
   - 缓解策略:如何应对这些风险?

4. **依赖性分析**:
   - 外部依赖:此解决方案依赖于什么?
   - 关键路径:哪些依赖在关键路径上?
   - 脆弱点:依赖可能在哪里引起问题?

5. **测试方法**:
   - 验证方法:如何测试实施?
   - 成功标准:如何衡量成功?
   - 失败场景:如何检测和解决失败?

6. **整体评估**:解决方案是否如所描述的可实施?哪些修改会提高可实施性?

此验证确保解决方案不仅在理论上合理,而且在实践中可行。
```

**Token 数量**:~240 tokens(仅模板)

**使用示例**:
- 用于工程解决方案
- 评估项目提案时
- 用于任何需要实际实施的解决方案

## 实现模式

以下是实现解决方案验证模板的简单 Python 函数:

```python
def verify_solution(problem, solution):
    """
    创建验证提议解决方案的提示。

    Args:
        problem (str): 原始问题
        solution (str): 要验证的提议解决方案

    Returns:
        str: 格式化的解决方案验证提示
    """
    return f"""
任务:验证以下解决方案的正确性。

问题:{problem}
提议的解决方案:{solution}

请遵循此验证过程:
1. **重述问题**:确认对所问内容的理解。
2. **检查方法**:使用的方法是否适合此问题?
3. **验证计算**:检查所有数学运算的准确性。
4. **检查逻辑**:检查推理中是否存在逻辑错误或漏洞。
5. **用例测试**:用具体示例或边缘情况测试解决方案。
6. **检查约束**:确保满足原始问题的所有约束。
7. **最终评估**:说明解决方案是否:
   - 正确:解决方案完全准确
   - 部分正确:解决方案存在小错误(请具体说明)
   - 不正确:解决方案存在重大缺陷(请具体说明)

如果发现错误,请清楚地解释并提出纠正建议。
"""
```

## 自我纠正循环

验证模板最强大的应用之一是自我纠正循环:

```
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  初始解决方案                                                        │
│       │                                                             │
│       ▼                                                             │
│  应用验证模板                                                        │
│       │                                                             │
│       ▼                                                             │
│  发现错误?                                                           │
│       │                                                             │
│       ├─────────────是─────────────┐                                │
│       │                             │                               │
│       ▼                             ▼                               │
│  否   │                        应用纠正                              │
│       │                             │                               │
│       ▼                             ▼                               │
│  最终验证解决方案 ◄──────────────────┘                               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

实现示例:

```python
def self_correction_loop(problem, max_iterations=3):
    """
    实现问题解决的自我纠正循环。

    Args:
        problem (str): 要解决的问题
        max_iterations (int): 最大纠正迭代次数

    Returns:
        dict: 最终解决方案和验证历史
    """
    # 初始解决方案
    solution = llm.generate(f"解决此问题:{problem}")

    history = [{"type": "solution", "content": solution}]
    iteration = 0

    while iteration < max_iterations:
        # 验证当前解决方案
        verification = llm.generate(verify_solution(problem, solution))
        history.append({"type": "verification", "content": verification})

        # 检查是否需要纠正
        if "正确:解决方案完全准确" in verification:
            break

        # 生成纠正的解决方案
        correction_prompt = f"""
        基于以下验证反馈,为原始问题提供纠正的解决方案。

        原始问题:{problem}

        先前的解决方案:{solution}

        验证反馈:{verification}

        请提供完全纠正的解决方案,解决验证中识别的所有问题。
        """

        corrected_solution = llm.generate(correction_prompt)
        history.append({"type": "correction", "content": corrected_solution})

        # 更新解决方案以进行下一次迭代
        solution = corrected_solution
        iteration += 1

    return {
        "problem": problem,
        "final_solution": solution,
        "verification_history": history,
        "iterations": iteration
    }
```

## 测量和优化

使用验证模板时,通过以下方式测量其有效性:

1. **错误检测率**:捕获了多少百分比的注入错误?
2. **误报率**:正确元素被错误标记的频率如何?
3. **纠正质量**:建议的纠正有多有效?
4. **迭代效率**:达到正确解决方案需要多少次迭代?

通过以下方式优化您的模板:
- 为专门领域添加特定领域的验证步骤
- 根据准确性的重要性调整审查级别
- 针对特定任务的常见错误类型进行优化

## 与其他工具结合

验证模板完成了认知工作流:

```
┌─────────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│                     │     │                 │     │                 │
│ 理解模板             │────►│ 推理模板         │────►│ 验证模板         │
│                     │     │                 │     │                 │
└─────────────────────┘     └─────────────────┘     └─────────────────┘
          ▲                                                │
          │                                                │
          └────────────────────────────────────────────────┘
                        (纠正循环)
```

这创建了一个完整的认知系统,可以:
1. 理解问题
2. 生成解决方案
3. 验证和纠正解决方案
4. 迭代直到达到令人满意的结果

## 下一步

- 探索 [composition.md](./composition.md) 了解组合多个模板的方法
- 了解如何在 [../cognitive-programs/basic-programs.md](../cognitive-programs/basic-programs.md) 中将这些模板集成到完整的认知程序中
- 在 [../cognitive-architectures/solver-architecture.md](../cognitive-architectures/solver-architecture.md) 中了解完整的认知架构
