# 上下文模式（Context Schemas）

> 从简单的原子级上下文到复杂的递归系统——标准化的 JSON 模式定义

这个目录包含了上下文工程的 JSON 模式定义，它们为设计、验证和演化 AI 上下文窗口提供了标准化的框架。

## 概述

上下文模式定义了构成现代 LLM 交互的所有关键组件——从最小的单个提示到复杂的多智能体编排系统。每个模式版本代表了我们对上下文架构理解的演进。

## 模式文件

### 核心模式

- **context.json** - 基础上下文工程模式 v1.0
- **context_v2.0.json** - 第2版：增加了检索和内存支持
- **context_v3.0.json** - 第3版：引入控制流和协议支持
- **context_v3.5.json** - 第3.5版：优化的紧凑格式
- **context_v4.0.json** - 第4版：多智能体和场论集成
- **context_v5.0.json** - 第5版：递归和自我改进机制
- **context_v6.0.json** - 第6版：完整的认知工具和符号架构
- **context_v7.0.json** - 第7版：量子语义学和元递归系统

## 模式版本演进

### v1.0 - 基础

最小化的上下文定义，涵盖：
- 单个提示和约束
- 基本的上下文结构
- 令牌预算和成本追踪

### v2.0 - 检索与内存

扩展功能，增加了：
- 检索增强生成（RAG）支持
- 持久化内存系统
- 上下文窗口管理

### v3.0 - 控制流

引入了编程概念：
- 顺序和条件执行
- 迭代循环和反馈
- 协议定义和操作

### v3.5 - 优化格式

紧凑且高效的表示：
- 减少冗余字段
- 改进的可读性
- 更好的解析性能

### v4.0 - 多智能体和场论

系统级别的架构：
- 多智能体编排
- 神经场表示
- 吸引子动力学
- 涌现行为

### v5.0 - 递归系统

自我改进和适应：
- 递归模式
- 自我反思机制
- 动态上下文更新
- 符号整合

### v6.0 - 认知工具和符号

完整的推理系统：
- 认知工具库
- 符号处理机制
- 推理框架
- 可解释性工具

### v7.0 - 量子语义学

前沿理论集成：
- 量子语义学原理
- 元递归系统
- 协作演化
- 跨模态集成

## 使用这些模式

### 基本用法

1. **验证上下文结构**
   ```json
   {
     "$schema": "http://context-engineering.org/schemas/contextEngineering.v6.json",
     "intent": "你的应用意图",
     "components": {
       // 你的上下文组件
     }
   }
   ```

2. **选择合适的版本**
   - 简单应用：使用 v3.5 或 v4.0
   - 复杂系统：使用 v5.0 或 v6.0
   - 前沿研究：使用 v7.0

3. **扩展和自定义**
   - 基于提供的模式创建派生版本
   - 在 `properties` 中添加自定义字段
   - 保持向后兼容性

### 验证

使用任何 JSON Schema 验证器来验证你的上下文：

```bash
# 使用 ajv-cli
ajv validate -s context_v6.0.json -d your_context.json

# 或者在 Python 中
import json
import jsonschema

with open('context_v6.0.json') as f:
    schema = json.load(f)

with open('your_context.json') as f:
    context = json.load(f)

jsonschema.validate(context, schema)
```

## 模式组件详解

每个模式包含以下主要部分：

### 核心字段

- **$schema** - Schema 版本标识符
- **intent** - 上下文的目的和意图
- **instanceID** - 唯一标识符
- **repositoryContext** - 项目和文件结构信息

### 主要组件

- **instructionSet** - 提示和约束定义
- **examplePairs** - 少样本学习示例
- **memorySystem** - 持久化和状态管理
- **retrievalContext** - 检索源和集成
- **agentLayer** - 多智能体编排
- **fieldTheory** - 神经场和动力系统
- **cognitiveTools** - 推理工具和协议
- **symbolicLayer** - 符号处理和抽象

## 最佳实践

### 设计原则

1. **清晰的意图** - 每个上下文都应明确其目的
2. **模块化结构** - 将关注点分离为不同的组件
3. **可验证性** - 使用 Schema 确保一致性
4. **可扩展性** - 设计能够容纳未来增长
5. **可观测性** - 包含用于跟踪和评估的元数据

### 版本管理

- 为重大更改使用新版本号
- 保持向后兼容性指南
- 在更新时记录迁移步骤
- 为每个版本提供示例

### 文档化

- 为所有自定义字段提供描述
- 包含使用示例
- 说明与其他组件的关系
- 记录任何约束或限制

## 常见用例

### 简单聊天机器人
使用 **v3.5** 或 **v4.0**：
- 单个系统提示
- 少量例子
- 基本内存管理

### 检索增强系统
使用 **v4.0** 或 **v5.0**：
- 检索配置
- 知识库连接
- 动态上下文组装

### 多智能体编排
使用 **v5.0** 或 **v6.0**：
- 智能体定义
- 通信协议
- 协调机制

### 高级推理系统
使用 **v6.0** 或 **v7.0**：
- 认知工具库
- 符号处理
- 推理框架

## 扩展指南

### 创建自定义模式

1. 选择基础版本
2. 复制并重命名为你的版本
3. 在 `$schema` 中更新 URI
4. 添加或修改属性
5. 更新文档和示例

### 兼容性检查

```json
{
  "$schema": "http://context-engineering.org/schemas/custom-v1.0.json",
  "allOf": [
    { "$ref": "context_v6.0.json" },
    {
      "properties": {
        "customField": {
          "type": "string",
          "description": "你的自定义字段"
        }
      }
    }
  ]
}
```

## 相关资源

- **[00_foundations/](../00_foundations/)** - 模式背后的理论基础
- **[20_templates/](../20_templates/)** - 使用这些模式的可复制模板
- **[30_examples/](../30_examples/)** - 完整的实现示例
- **[40_reference/](../40_reference/)** - 深入的参考文档

## 贡献

如果你创建了新的模式版本或扩展：

1. 添加描述性的版本号和日期
2. 包含详细的 Schema 定义
3. 提供示例和文档
4. 说明与之前版本的差异
5. 提交 PR 进行审查

## 常见问题

### Q: 我应该使用哪个版本的模式？
**A:** 从最新的稳定版本（目前是 v6.0）开始。对于前沿研究，考虑 v7.0。

### Q: 我可以混合使用来自不同版本的组件吗？
**A:** 不推荐。选择单个版本并根据需要进行扩展。

### Q: 如何创建向后兼容的模式更新？
**A:** 使用 JSON Schema 的 `allOf` 关键字来扩展而非替换现有定义。

### Q: 这些模式是否适用于生产系统？
**A:** 是的，它们设计用于从原型到生产规模的系统。使用验证来确保一致性。

## 许可证

这些模式与主项目使用相同的许可证。详见 [LICENSE](../LICENSE)

## 联系与支持

对于问题或建议，请参见主项目的 [CONTRIBUTING.md](../.github/CONTRIBUTING.md) 指南。
