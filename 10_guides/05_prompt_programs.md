# 05. 提示程序（Prompt Programs）

## 概述

本指南介绍如何将提示组织成可重用、可组合的程序，以实现更复杂和强大的AI系统。

## 核心概念

1. **模块化提示** - 将提示分解为可重用的组件
2. **提示组合** - 组合多个提示以解决复杂问题
3. **条件执行** - 根据条件选择不同的提示分支
4. **循环和迭代** - 实现重复的提示执行
5. **状态管理** - 跟踪和管理提示间的状态

## 提示程序架构

### 基本结构

```
提示程序
├── 初始化阶段
│   ├── 设置变量
│   ├── 加载上下文
│   └── 定义目标
├── 处理阶段
│   ├── 多个提示块
│   ├── 条件分支
│   └── 循环结构
├── 聚合阶段
│   ├── 收集结果
│   ├── 综合信息
│   └── 生成最终输出
└── 验证阶段
    ├── 检查质量
    ├── 错误处理
    └── 反馈循环
```

## 设计模式

### 模式 1: 管道（Pipeline）

**结构**:
```
输入 → 步骤1 → 步骤2 → 步骤3 → 输出
```

**示例**:
```
原始文本 → 清洁 → 提取信息 → 格式化 → 输出
```

**适用场景**:
- 顺序处理
- 数据转换
- 逐步精化

### 模式 2: 分支（Branching）

**结构**:
```
输入
  ├─ 条件1 → 分支A → 输出1
  ├─ 条件2 → 分支B → 输出2
  └─ 条件3 → 分支C → 输出3
```

**示例**:
```
问题分类
  ├─ 技术问题 → 技术支持流程
  ├─ 账户问题 → 账户管理流程
  └─ 其他问题 → 一般咨询流程
```

**适用场景**:
- 根据输入选择不同路径
- 多个处理分支
- 决策树

### 模式 3: 循环（Loop）

**结构**:
```
初始化
  ↓
执行提示
  ↓
评估结果
  ↓ 未完成
重复
  ↓ 完成
输出
```

**示例**:
```
生成代码 → 测试 → 错误? → 调试提示 → 重新生成
                  ↓ 无错误
               返回代码
```

**适用场景**:
- 迭代改进
- 直到满足条件
- 多轮对话

### 模式 4: 分而治之（Divide and Conquer）

**结构**:
```
大问题
  ├─ 分解1 → 解决1
  ├─ 分解2 → 解决2
  ├─ 分解3 → 解决3
  └─ 合并 → 综合答案
```

**示例**:
```
长文档总结
  ├─ 分割成段落
  ├─ 各段独立总结
  ├─ 综合各段摘要
  └─ 生成整体总结
```

**适用场景**:
- 大规模问题
- 并行处理
- 复杂分析

### 模式 5: 多智能体（Multi-Agent）

**结构**:
```
协调器
├─ Agent1（专家1）
├─ Agent2（专家2）
├─ Agent3（专家3）
└─ 聚合结果
```

**示例**:
```
复杂决策
├─ 技术评估
├─ 成本分析
├─ 风险评估
└─ 综合建议
```

**适用场景**:
- 需要多个视角
- 复杂决策
- 专业领域分析

## 实现技巧

### 1. 模块设计

```python
# 定义可重用的提示模块
class PromptModule:
    def __init__(self, name, template, parameters):
        self.name = name
        self.template = template
        self.parameters = parameters

    def execute(self, context):
        # 执行提示
        pass

    def validate_output(self, output):
        # 验证输出
        pass
```

### 2. 上下文管理

```python
# 管理提示间的上下文传递
class PromptContext:
    def __init__(self):
        self.variables = {}
        self.history = []

    def set(self, key, value):
        self.variables[key] = value

    def get(self, key):
        return self.variables.get(key)

    def save_step(self, step_name, result):
        self.history.append((step_name, result))
```

### 3. 错误处理

```python
# 在提示程序中处理错误
try:
    result = execute_prompt(input_data)
    if not validate_result(result):
        # 尝试替代方案
        result = execute_fallback_prompt(input_data)
except Exception as e:
    # 错误处理和恢复
    result = handle_error(e, input_data)
```

### 4. 性能优化

- **缓存** - 缓存重复的提示结果
- **并行化** - 并行执行独立步骤
- **批处理** - 批量处理多个请求
- **流式处理** - 流式返回结果

## 实际例子

### 例子 1: 文档分析系统

```
输入: 原始文档
  ↓
步骤1: 清洁和规范化
  ↓
步骤2: 提取关键信息
  ↓
步骤3: 进行情感分析
  ↓
步骤4: 生成摘要
  ↓
步骤5: 识别行动项
  ↓
输出: 结构化分析报告
```

### 例子 2: 客服助手系统

```
客户输入
  ↓
意图识别
  ├─ 常见问题? → FAQ数据库查询 → 返回答案
  ├─ 账户问题? → 账户查询系统 → 返回账户信息
  └─ 复杂问题? → 逐步问诊 → 生成解决方案
  ↓
满意度评估
  ├─ 满意 → 结束
  └─ 不满意 → 升级到人工客服
```

### 例子 3: 研究论文分析

```
论文输入
  ↓
并行分析
├─ Agent1: 提取核心贡献
├─ Agent2: 评估方法论
├─ Agent3: 识别局限性
└─ Agent4: 分析影响
  ↓
结果综合
  ↓
生成分析报告
```

## 调试和优化

### 调试技巧

1. **日志记录** - 记录每一步的输入和输出
2. **断点** - 在关键步骤暂停执行
3. **验证检查** - 在各步骤验证中间结果
4. **单元测试** - 测试各个模块

### 优化方向

- **减少步骤数** - 简化程序流程
- **减少Token使用** - 优化提示内容
- **提高并行度** - 增加并行执行
- **改进缓存** - 更好地利用缓存

## 最佳实践

1. **清晰的设计** - 明确定义程序流程
2. **模块化** - 创建可重用的模块
3. **错误处理** - 优雅处理失败
4. **文档化** - 记录程序逻辑
5. **测试** - 充分测试各个部分
6. **监控** - 跟踪系统性能
7. **迭代改进** - 基于使用情况改进

## 高级主题

- **动态提示生成** - 在运行时生成提示
- **学习反馈** - 从执行结果学习
- **自适应程序** - 根据上下文调整程序
- **分布式执行** - 在多个系统上执行
- **版本管理** - 管理提示程序的版本

## 工具和框架

- LangChain - 提示链框架
- LlamaIndex - 数据索引和检索
- Semantic Kernel - 提示编排
- Agents and Tools - Agent框架

## 下一步

- 学习 `06_schema_design.md` - 结构化架构设计
- 探索 `07_recursive_patterns.md` - 递归和自相似模式
- 研究 `00_min_prompt.md` - 基础提示设计

## 相关资源

- 提示工程最佳实践
- LLM应用架构
- 系统设计原理
- 软件工程设计模式
